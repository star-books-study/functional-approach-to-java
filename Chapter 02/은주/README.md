# Chapter 02. 함수형 자바
- 람다 표현식 : 자바에서 **함수형 프로그래밍 접근 방식의 핵심 요소**

## 2.1. 자바 람다란?
- 람다는 어떠한 객체에도 속하지 않는 익명 메서드와 비슷하다
```java
() -> System.out.println("hi");
```

## 2.2. 람다 문법
```
(<parameters>) -> { <body> }
```
- 매개변수
  - 메서드 인수와는 다르게 컴파일러가 매개변수의 타입을 추론할 수 있는 경우, **매개변수의 타입을 생략할 수 있다**
  - 묵시적 타입이 지정된 매개변수, 명시적 타입 지정된 **매개변수를 혼용하는 것은 허용되지 않는다**
  - 매개변수가 하나인 경우는 괄호를 생략할 수 있지만, 매개변수가 없거나 둘 이상이면 괄호를 사용해야 한다
- 화살표
  - 매개변수와 람다 바디를 구분하기 위해 사용한다
- 바디
  - 단일 표현식 또는 코드블럭으로 구성된다
  - 한줄로 작성된 표현식의 계산된 결과는 **암시적으로 return 문 없이 반환된다**
  - 중괄호로 감싸져 있으며 값을 반환할 경우 명시적으로 return 문을 사용해야 한다

### 2.1.2. 함수형 인터페이스
- 람다 문법은 기존의 인터페이스를 기반으로 하위 호환성을 유지하고 있다
- 람다 표현식은 **특화된 인터페이스의 하위 타입**으로 표현되며, 이를 `함수형 인터페이스` 라고 한다.
- 자바 인터페이스 바디 구성 
  - 메서드 시그니처
    - **인터페이스에 반드시 구현되어야 하는 추상메소드 시그니처** 포함됨
  - 디폴트 메소드
    - 인터페이스를 구현하는 **모든 클래스가 이를 재정의 가능하지만 필수는 아님**
  - 정적 메소드
    - 클래스 레벨에서 **필수적으로 구현되어야 하는 메서드. 하지만 상속 불가하며 오버라이딩 불가**
  - 상수
- 인터페이스를 '함수형 인터페이스' 로 만드는 조건
  - `SAM (Single Abstract Method)` : **추상메서드를 1개** 가진 인터페이스의 특성
  - 디폴트 메서드, 정적 메서드는 추상 메서드가 아니기에 여러개 존재해도 무방
  - SAM은 람다의 기능을 보완하는 데 자주 사용됨
    - ❓어떤 기능을 보완하는데 사용되지? 어떻게 보완?
- 단 하나의 추상메서드를 가진 모든 인터페이스는 자동으로 함수형 인터페이스가 된다
- @FunctionalInterface 는 꼭 필요하진 않지만 **컴파일러와 다른 어노테이션 기반 도구에게 해당 인터페이스가 함수형 인터페이스임을 알려주고 SAM 요구사항을 반드시 따라야 한다는 것을 알려준다**
- 해당 마커 어노테이션을 달면 **코드와 인터페이스의 의도를 명확히 표현하며, 추후에 의도하지 않은 변경으로부터 코드를 보호하는 역할을 한다**
- **인터페이스가 SAM 요구사항을 충족한다면, 해당 인터페이스는 람다로 표현할 수 있다.**

### 2.1.3. 람다와 외부 변수
- 람다도 '순수함수와 참조 투명성' 이라는 핵심 개념을 따르지만, **유연성을 위해 어느정도의 불순성을 허용**한다
- `캡처` 를 통해 람다가 정의된 생성스코프 내의 상수, 변수를 획득할 수 있다
```java
public class LambdaCapture {

    public static void main(String... args) {
        Runnable r = capture();
        r.run();
    }

    private static Runnable capture() {
        var theAnswer = 42;

        Runnable printAnswer = () -> System.out.println("the answer is " + theAnswer);

        return printAnswer;
    }
}
```
- 캡처 람다와 논캡처 람다의 주요 차이점은 **JVM 최적화 전략**에 있다
  - JVM 은 실제 사용 패턴에 기반하여 다양한 전략으로 람다를 최적화한다
  - ❓ JVM 최적화 전략이 어떻게 다른지?
- 변수가 캡처되지 않은 경우 람다는 내부적으로 간단한 정적 메서드가 될 수 있고, 익명 클래스와 같은 대안적인 접근 방식의 성능을 능가할 수 있다
  - ❓내부적으로 간단한 정적 메서드가 될 수 있다? 
- 변수를 캡처하는 상황에서 JVM 은 **추가적인 객체 할당이 발생하며, 성능 및 가비지 컬렉터 시간에 영향**을 줄 수 있다
- 변수 캡처를 피해야 하는 또 다른 이유 중 하나는 해당 변수가 `Effectively final` (**변수가 선언된 후 그 값이 변경되지 않음**) 이어야 한다는 필요성이 있기 때문이다

#### Effectively final
- JVM 은 캡처된 변수를 안전하게 사용하고, 최상의 성능을 얻기 위해 반드시 지켜야 하는 요구사항이 있다.
  - **반드시 캡처되는 변수는 Effective Final 이어야 한다.**
- `final` 키워드를 명시적으로 사용하거나, **초기화된 이후에 상태가 변경되지 않도록 유지**해야 한다