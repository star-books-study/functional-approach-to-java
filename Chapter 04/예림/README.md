# Chapter 04. 불변성
- 자료 구조를 다룬다는 것의 의미
  - OOP에서는 객체에 캡슐화된 가변 프로그램 상태를 다루는 것
  - 함수형 접근 방식에서는 불변성이 데이터를 처리하는 주요 방법이며 다양한 개념의 전제 조건
- 이 장에서는 자료구조를 불변하게 만드는 방법에 대해 배운다. (feat.JDK에서 이미 제공하는 불변 타입과 제3자 라이브러리)

## 4.1 객체 지향 프로그래밍의 가변성과 자료 구조
- 자바에서는 객체의 상태를 가변 형태로 캡슐화 (setter)
- 가변 상태를 다루는 가장 일반적인 형태 : JavaBean과 POJO
  - POJO
    - 설계에 어떠한 제한도 없고 비즈니스 로직 상태를 단지 캡슐화하는 것이 목적
    - 불변성을 갖도록 설계할 수도 있음
    - getter, setter 제공
  - JavaBean
    - 내부 검사와 재사용성을 가능하게 해주며 이를 위해 특정 규칙을 따르도록 되어 있음
- 컬렉션 프레임워크 같은 JDK에 있는 자료 구조들은 대부분 가변 상태와 직접 변경이 가능한 방식으로 설계됨
- 가변 상태는 복잡성과 불확실성을 유발함
  - 특히 동시성 프로그래밍의 많은 문제가 가변성에서 발생
- 끊임없는 단위 테스트와 상태 검증 작업이 필요 -> 추가 작업 증가


## 4.2 함수형 프로그래밍의 불변성
- 자료 구조는 생성 후에 변경할 수 없어야 한다. 이 원칙은 함수형 프로그래밍 언어에서 기본으로 지원한다.
- 불변 자료 구조를 변경하려면 의도한 변경 사항을 반영한 새로운 복사본을 생성해야 한다.
- 이러한 불변성은 함수형 접근 방식을 넘어 자바에서는 충분한 가치가 있다.
  - 예측 가능성
  - 유효성 : 초기화 후, 자료 구조는 완전한 상태가 된다. 단 한 번의 검증만 필요하며 유효(또는 무효) 상태로 유지된다.
  - 숨겨진 사이드 이펙트 없음 : 불변 자료 구조는 항상 그대로이기 때문에 사이드 이펙트가 바생하지 않음
  - 스레드 안전성 : 불변 자료 구조는 스레드 경계를 자유롭게 이동 가능
  - 캐시 가능성 및 최적화 : 자료 구조가 생성 직후부터 변경되지 않았기 때문에 신뢰하고 캐싱 가능
  - 변경 추적 : 모든 변경이 새로운 자료 구조를 생성한다면 이전 상태를 저장함으로써 이전 상태 추적 가능
- 이 모든 이점은 선택한 프로그래밍 패러다임과는 독립적
- 만약 함수형 접근 방식이 여러분의 코드에 맞지 않다고 하더라도 여전히 데이터 처리에서 불변셩을 통해 큰 이점을 얻을 수 있음

## 4.3 자바 불변성 상태
- 자바 초기 디자인은 불변성을 포함하지 않았음. 자바 14가 출시되면서 불변 자료 구죈 렠드를 도입하면서 모든 것이 바뀜.
### 4.3.1 java.lang.String
- String 타입에는 높은 최적화와 안정성이 필요하다. 이러한 최적화 방법 중에는 '불변성'이 있다.
- 문자열을 연결하면 그 결과로 새로운 String 객체가 생성된다. 그래서 자바 개발자들은 지속적으로 문자열 연결을 사용하는 것을 피하도록 교육 받는다.
- 물론 JVM에서는 가비지 컬렉션을 통해 필요 없어진 인스턴스를 정리하지만 끊임없이 생성디ㅚ는 String 객체로 인한 메모리 오버헤드는 실제 런타임에 부담이 될 수 있다.
- 따라서 JVM은 문자열 연결을 String Builder로 대체하거나 Invokedynamic 명령 코드를 활용하는 등 여러 최적화 전략을 내부적으로 사용한다.
- String 타입은 가장 기본적으로 널리 사용되는 타입이기 때문에 불변성을 유지하는 것이 합리적이다.
  - 동시성 문제 해결
- 또한, 문자열 리터럴도 JVM에서 특별한 관리를 받는다.
  - 문자열 풀링 덕분에 동일한 리터럴은 한 번만 저장되어 사용되므로 힙 메모리 절약에 도움이 된다.
  - 리터럴을 생성하는 대신, 명시적으로 생성자 중 하나를 호출하여 새로운 String을 할당하는 것으로 풀링을 우회할 수도 있다.
  - 반대로, 인스턴스에서 intern 메서드를 호출하여 문자열 풀에서 동일한 내용의 문자열을 반환할 수도 있다.
- 그러나 기술적인 관점에서 보면 String 타입은 '완전히' 불변하지 않는다.
  - 성능 고려로 인해 String은 hashCode를 지연해서 계산한다. 전체 문자열을 읽어야 하기 때문이다.
- 이러한 특성들로 인해 String은 최소한 사용성 관점에서는 원시 타입과 객체 타입 사이에 놓여있다고 볼 수 있다.

### 4.3.2 불변 컬렉션
- 자바의 컬렉션 프레임워크는 불변성을 중심으로 설계되지는 않았지만, 아래 세 가지 방법을 통해 어느 정도의 불변성을 제공하고 있다.
  - 변경 불가능한 컬렉션
  - 불변 컬렉션 팩토리 메서드 (자바 9+)
  - 불변 복제 (자바 10+)
- 이 모든 옵션은 new 키워드를 사용해 직접 인스턴스화할 수 있는 public 타입은 아님
- 필요한 인스턴스를 생성하기 위한 **정적 편의 메서드**를 제공함.
- 이들은 얕은 불변성만 가지고 있어, 요소를 추가하거나 제거하는 것은 불가능하고 요소 자체의 불변성을 보장하지는 않음


#### 변경 불가능한 컬렉션
- java.util.Collections 클래스의 일반 정적 메서드 중 하나를 호출해 기존 컬렉션에서 생성한다.
  - unmodifieableCollection
  - unmodicfiableSet
  - ...
- 각 메서드는 인수로 받은 타입과 같은 타입을 ㅈ반환한다.
- 원본 인스턴스와 반환된 인스턴스 간 차이점은 반환한 인스턴스를 수정할 때 UnsupportedOperationException이 발생한다는 것

- '변경 불가능한 뷰'는 기존 컬렉션에 대한 추상화에 불과하기 때문에 원본 참조를 통해 데이터를 여전히 참조할 수 있다는 문제가 있음.
- '변경 불가능한 뷰'는 주로 반환값으로 사용될 컬렉션에 대해 원치않는 변경을 막기 위해 사용


#### 불변 컬렉션 팩토리 메서드
- 기존 컬렉션을 기반으로 하지 않지만 원하는 요쇼들은 직접 해당 컬렉션 타입의 정적 편의 메서드를 통해 전달해야 함
  - List<E> of (E e1, ...)
  - Set<E> of (E e1, ...)
  - Map<K, V> of (K k1, V v1, ...)
- 각 팩토리 메서드는 0개 이상의 요소를 받아들일 수 있으며, 제공된 요소의 개수에 따라 최적의 내부 컬렉션 타입사용


#### 불변 복제
- 다음 세 가지 유형의 static 메서드 copyOf를 호출하여 더 깊은 수준의 불변성 제공
  - Set<E> copyOf(Collection<? extends E> col1)
  - List<E> copyOf(Collection<? extends E> col1)
  - Map<K,V> copyOf(Map<? extends K, ? extends V> map)
- 단순히 뷰를 제공하는 것이 아니라, 새로운 컨테이너를 생성하여 요소들의 참조를 독립적으로 유지

- 복사된 컬렉션은 원본 리스트에 요소를 추가하거나 제거하는 것을 방지하지만, 실제 요소 자체는 여전히 공유되며 변경 가능

 