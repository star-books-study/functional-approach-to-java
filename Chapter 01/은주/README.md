# 옮긴이의 말
- 함수형 프로그래밍은 새로운 개념이 아니다
  - 주로 복잡한 애플리케이션, 시스템 개발에 있어 **고수준의 추상화, 불변성, 효율적인 병렬 처리** 등의 장점을 제공한다
- 함수형 프로그래밍은 대규모 데이터 처리, 분산 시스템, 클라우드 컴퓨팅 등 현대 개발 환경의 복잡한 요구 사항에 효과적이다
  - ❓ 이유는?
- 기존의 다양한 명령형 프로그래밍 언어들도 함수형 개념을 도입하여 표현성과 유연성이 향상되었다

# 이 책에 대하여
- 객체지향 프로그래밍은 가장 유명하고 검증된 프로그래밍 패러다임 중 하나지만, 항상 최적의 해결책이 되지는 않는다
- FP 패러다임은 문제 해결에 대한 새로운 접근 방식을 제안한다
## 새로운 하드웨어에는 새로운 사고방식이 필요하다
- 더 빠른 처리 속도가 아닌, 더 많은 코어를 가진 새로운 하드웨어의 장점을 최대한 살리기 위해 현대의 프로그램에서 작업 방식을 고민해볼 필요가 있다
- 생산성을 저해하거나, 복잡성을 증가시키지 않으면서, **더 많은 코어를 효율적으로 활용할 수 있는 방법**에 대해 기술적으로 고민해야 한다
- 객체지향 프로그래밍에서는 병렬 처리를 통한 소프트웨어의 수평 확장이 쉽지 않다
  - ❓ 이유는?
- 문제가 순차적이거나, 상호의존적인 작업으로 구성되는 경우 병렬성보다 동시성이 적절할 수 있다
- 문제가 간단하고 서로 관련이 없는 하위 문제로 분할 가능한 경우에는 병렬 처리가 훨씬 효과적이다
  - 이러한 경우에 함수형 프로그래밍이 유용하게 사용될 수 있다
- 함수형 프로그래밍의 고유한 특징에는 `비상태성`과 `불변성`이 있는데, **병렬성 및 동시성 처리 환경에서 작고 안정적이고 재사용 가능하며 고품질 작업**을 하는데 필요한 모든 도구를 제공한다

## 자바도 역시 함수형 언어다
- 스칼라 : 객체지향 프로그래밍과 함수형 프로그래밍 패러다임을 효과적으로 결합한 고급 프로그래밍 언어
- **프로그래밍 언어 수준과는 관계없이 대부분의 함수형 원칙을 구현할 수 있다**

# Chapter 01. 함수형 프로그래밍 소개
## 1.1. 어떤 것이 언어를 '함수형' 으로 만드는가?
- 실제로 어떤 프로그래밍 언어를 '함수형' 으로 분류해야 하는지에 대해서 논쟁의 여지가 있다
- 프로그래밍 언어가 `추상 함수` 를 **생성, 조합함으로써 논리 연산을 표현**할 수 있을 때 함수형 언어로 간주된다
  - 이 개념은 람다 대수에 뿌리를 두며, 람다 대수는 추상 함수를 이용하여 수학연산을 표현하고, 이를 변수에 바인딩하는 방법을 의미한다
- 람다 대수의 구성 요소
  - 추상화 : 익명 함수 (람다)
  - 응용 : 값에 추상화가 적용되어 결과 생성
  - 베타 축약 : 추상화된 변수를 적용된 인수로 대체
- 명령형 프로그래밍 : 컴퓨터에게 특정 작업을 수행하기 위해 무엇을 해야하는지 명령해서, 문장의 순서대로 작업을 수행한다
- 함수형 프로그래밍이 되려면 **제어 흐름이나 알고리즘을 설명하지 않고, 연산의 논리를** `선언적 문장`으로 표현할 수 있어야 한다
  - 문장이 아닌 `표현식` 을 사용해서 결과와 프로그램이 작동하는 방식을 설명한다
  - 즉, 무엇을 해야하는지가 아닌 `무엇을 원하는 지`를 표현한다
- 자바 표현식 : 연산자, 피연산자, 메소드 호출로 구성됨. (연산 정의)
- 문장 : 코드가 수행하는 동작을 기술한 독립적인 실행 단위, 리턴값이 없는 메소드 호출을 포함
  - 변수 값 할당 또는 변경, 리턴값 없는 메소드 호출, 제어문
- 표현식과 문장의 기본적 차이는 값의 반환 유무이지만, 자바 같은 다중 패러다임 언어에서는 경계가 모호하다

## 1.2. 함수형 프로그래밍의 개념
- 함수형 프로그래밍은 `선언적` 스타일로, `무엇을 해결할 것인가` 에 초점을 두고 있다
  - 이는 `어떻게 해결할 것인가` 를 고민하는 `명령형` 접근 방식과 상반된다

### 1.2.1. 순수 함수와 참조 투명성
- 함수형 프로그래밍에서는 함수를 순수함수, 불순함수로 분류한다
- 순수함수의 조건
  - **동일한 입력에 대해, 항상 동일한 출력**을 반환한다 (`참조 투명성`)
  - **어떠한 사이드이펙트 없이** 자기 충족적 성질을 가진다
    - 인수값을 변경하거나, I/O 를 사용하는 등 글로벌 상태에 영향을 미치지 않는다
- 두 조건 중 하나라도 위반하면 불순 함수로 간주된다
  ```java
  public String toLowerCase(String str) {
    return str;
  }
  ```

### 1.2.2. 불변성
- 불변성 : 초기화 된 이후 자료 구조를 더이상 변경할 수 없다
  - 일관성 보장, 예측 가능, 이해하기 쉬움
- 불변 자료 구조는 순수 함수와 마찬가지로 **비동기적이고 병렬적인 환경에서 안정적으로 작동**한다
- 동기화 문제나 범위를 벗어난 상태 변경과 같은 문제는 초래되지 않는다
- 하지만 자료 구조가 초기화된 이후 절대 변경되지 않으면 유용하지 않은 프로그램이다
  - 따라서 자료 구조를 직접 변경하는 대신 변경된 상태를 포함하는 업데이트 버전을 생성한다
  - 하지만 매번 데이터 변경될 때마다 새로운 자료 구조를 생성하는 것은 매번 데이터를 복사해야 하므로 비효율적이다
    - 많은 프로그래밍 언어에서는 구조 공유를 사용하여 효율적인 복사 메커니즘을 제공하여 **데이터 변경에 대한 비효율성을 최소화**한다

### 1.2.3. 재귀
  - 순수 함수형 프로그래밍은 반복문(loop), 반복자(iterator) 대신에 **재귀를 선호**하는 경향이 있다
    - ❓ 선호하는 이유는?
    - 하지만 반복적으로 함수를 호출하면 비효율적일 수 있고 스택 오버플로의 위험성을 갖는다
  - 따라서 많은 함수형 언어는 스택 프레임을 줄이기 위해 꼬리 물기 최적화 (tail call optimization) 또는 루프 언롤링 (loop unrolling) 과 같은 최적화 기법을 활용한다
    - 자바는 미지원

### 1.2.4. 일급 함수와 고차 함수
- `일급함수` : 프로그래밍 언어에서 함수를 소위 '일급 객체' 로 대우하는 것
  - 함수 자체를 **다른 함수에 인수로 전달하거나, 반환값으로 사용하거나, 변수에 할당할 수 있는 함수**를 지칭한다
- 고차 함수는 이 일급 객체의 특성을 바탕으로 함수를 인수로 받거나, 반환하거나, 혹은 2가지를 모두 가능하게 한다

### 1.2.5. 함수 합성
- 순수함수를 결합해서 더 복잡한 표현식을 만들어낼 수 있다
  - ex. f(x), g(y) 를 h(x) = g(f(x)) 로 결합할 수 있다
- 이렇게 하면 함수를 가능한 한 **작고 명확하게** 만들 수 있어 `재사용` 하기가 더 쉬워지며, 빠르게 조합하여 사용할 수 있다

### 1.2.6. 커링
- 커링 함수 : 여러 개의 인수를 받는 함수들을 분리하여 인수를 하나씩만 받는 함수의 체인으로 변환
  - 한 개의 함수가 2개 이상의 인수를 갖는 함수들의 함수로 표현될 수 있음을 완벽하게 설명한다

### 1.2.7. 부분 적용 함수 애플리케이션
- 부분 적용 함수 애플리케이션 : 기존 함수의 인수 중 일부만 제공하여 새로운 함수를 생성하는 과정
  - 종종 커링과 혼동되지만, 부분 적용된 함수에 대한 호출은 결과를 반환, 커링 체인의 또 다른 함수를 반환하지 않음

### 1.2.8. 느긋한 계산법
- 느긋한 계산법 : 표현식의 계산을 그 **결과가 실제로 필요한 시점까지 지연**시키는 계산 전략
  - 표현식을 **어떻게 생성하는지, 표현식을 언제 사용하는지에 대한 문제를 분리**하는 개념
  - ex. for문이나 if-else 문도 모든 반복이나 분기를 즉시 계산하는 것은 의미가 없다. 따라서 런타임 중에는 필요한 분기와 반복만 계산한다
- 느긋함은 참조 투명성과 아주 잘 어울린다. 
  - 표현식과 그 결과물 간에 차이가 없다면 결과에 영향을 주지 않고 연산을 지연할 수 있다

## 1.3. 함수형 프로그래밍의 장점
#### 간결성
- 가변상태에서 사이드 이펙트가 없는 경우 함수는 보통 더 작아지며, '**해야 할 일' 만 수행** 한다

#### 일관성
- 불변 자료 구조는 **신뢰성과 일관성**이 있다

#### (수학적) 정확성
- 일관된 자료 구조를 갖춘 간결한 코드는 자동으로 더 '**정확한**' 코드를 만들며 버그를 발생시킬 수 있는 부분이 줄어든다
- 코드가 순수할수록, 논리적 추론이 더 쉬워지므로 디버깅, 테스트가 간단해진다

#### 안전한 동시성
- 함수형 개념을 활용하여 거의 비용 없이 **안전한 병렬 처리**의 이점을 누릴 수 있다

#### 모듈성
- 작고 독립적인 함수는 **간단한 재사용성과 모듈성**을 제공한다
- 작은 부분을 쉽게 통합하여 더 복잡한 작업을 할 수 있는 강력한 도구를 제공한다

#### 테스트 용이성
- 순수 함수, 참조 투명성, 불변성, 역할 분리와 같은 많은 함수형 개념은 **테스트와 검증을 더 쉽게** 만든다 

## 1.4. 함수형 프로그래밍의 단점
#### 학습 곡선
- 고급 수학 용어와 개념을 기반으로 하기에 다소 어렵게 느껴질 수 있다

#### 고수준 추상화
- 함수형 프로그래밍은 객체지향 프로그래밍보다 `더 높은 추상화 수준`을 사용하여 자료 구조를 표현한다
- 그만큼 우아하게 표현될 수 있지만 종종 이해하기 어려울 수 있다
  
#### 상태 처리
- 불변성 접근 방식은 많은 버그 가능성을 제거하지만, 자료 구조를 실제로 변경해야 하는 경우 상태 변경이 어려울 수 있다

#### 성능 영향도
- 동시성 환경에서 사용하기 더 쉽고 안전하지만, 다른 패러다임과 비교하여 반드시 빠르다는 것은 아니다
- 불변성이나 재귀와 같은 많은 함수형 기술은 **오버헤드로 인해 성능이 저하**될 수 있다
  - 따라서 복사를 최소화하는 특수화된 자료구조나 재귀에 대해 컴파일러 최적화 같은 다양한 최적화 기법을 도입한다

#### 최적의 문제 상황
- 모든 문제 상황이 함수형 접근에 적합한 것은 아니다
<br>

- 개발자로서 **패러다임과 프로그래밍 접근 방식의 장점과 단점 사이에서 균형을 찾아야 한다.**

## 핵심 요약
- 함수형 프로그래밍은 '람다 대수' 라는 수학적 원리를 기반으로 한다
- 문장보다 `표현식`을 기반으로 하는 `선언적` 코딩 스타일이 필수이다
- 함수형 개념과 실제 적용 사이에는 타협이 필요하다