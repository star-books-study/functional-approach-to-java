# Chapter 01. 함수형 프로그래밍 소개

## 1.1 어떤 것이 언어를 '함수형'으로 만드는가?
- 언어를 '함수형'으로 규정하는 데 어떤 요소들이 필요한가?
- 프로그래밍 언어가 추상 함수<sub>abstract function</sub>를 생성하고 조합함으로써 논리 연산을 표현할 수 있을 때 함수형 언어로 간주된다.
  - 람다 대수에 뿌리를 둔 개념
### 람다 대수
- 추상 함수를 이용하여 수학 연산을 표현하고, 이를 변수에 바인딩하는 방법

**세 가지 구성 요소**
- 추상화 : 단일 입력을 받는 익명함수, 즉 람다
- 응용 : 값에 추상화가 적용되어 결과를 생성한다. (함수나 메서드 호출)
- 베타 축약 : 추상화된 변수를 적용된 인수로 대체한다.
  $$ f = \lambda x E $$
  - `수학적 함수 선언식`을 의미
  - 각 항의 의미
    - $x$ : 값을 나타내는 변수나 인수
    - $E$ : 논리를 포함하는 표현식 또는 용어
    - $\lambda x E$ : 단일 입력을 받는 추상화된 익명 함수
    - $f$ : 추상화에 인수를 적용하는 결과 함수

- 이러한 부분들은 자바의 람다와 구현 방식이 거의 유사
  - 이차 함숫값을 계산하기 위한 함수의 추상화인 $\lambda x .x*x$는 자바 버전과 거의 동일하게 표현됨
    ```java
    Function<Integer, Integer> quadratic = value -> value * value;
    ```

- 함수형 프로그래밍이 되기 위해서는 제어 흐름이나 알고리즘을 설명하지 않고, 연산의 논리를 `선언적 문장`으로 표현할 수 있어야 함
- 선언적 프로그래밍에서는 문장이 아닌 표현식을 사용하여 결과와 프로그램이 작동하는 방식을 설명
- 즉, 무엇을 해야 하는지가 아닌 **무엇을 원하는지를 표현**한다.
- 자바의 표현식<sub>expression</sub>은 연산자, 피연산자, 메서드 호출로 구성
- 자바의 문장<sub>statement</sub>은 코드가 수행하는 동작을 기술한 독립적인 실행 단위 / 리턴값이 없는 메서드 호출을 포함
- 표현식과 문장의 기본적인 차이는 **값의 변환 유무**
- 자바와 같은 다중 패러다임 언어에서는 종종 이들 사이의 경계가 모호함.


```java
int newTreasuresFound = foundTreasure(6);
```
- `findTreasure(6)` 함수 호출은 함수형 표현식이지만 `newTreasuresFound`은 문장이다.

## 1.2 함수형 프로그래밍의 개념
- 함수형 프로그래밍은 주로 추상 함수에 기반을 두고 있으며 이 패러다임을 구성하는 많은 개념은 선언적 스타일로 **'무엇을 해결할 것인가'**에 초점을 맞추고 있다.
- 이것은 '어떻게 해결할 것인가'를 고민한느 명령형 접근 방식과 상반

### 1.2.1 순수 함수와 참조 투명성
- 함수형 프로그래밍에서는 함수를 순수 함수<sub>pure function</sub>와 불순 함수<sub>impure function</sub>로 분류
- `순수 함수`는 다음 두 가지 조건을 만족해야 한다.
  - **동일한 입력에 대해 항상 동일한 출력을 반환한다.**
  - **어떤 사이드 이펙트 없이 자기 충족적 성질을 가진다.**
- 순수 함수 예시
  ```java
  public String toLowercase(String str) {
    return str;
  }
  ```
- 두 가지 조건 중 하나라도 위반하면 `불순 함수`로 간주
- 불순 함수 예시
  
  ```java
  public String buildGreeting(String name) {
    var now = LocalTime.now();
    if (now.getHour() < 12) {
      return "Good morning" + name;
    } else {
      return "Hello " + name; 
    }
  }
  ```
- 단지 코딩 스타일과 패러다임에 따라 다른 방식으로 사용할 뿐, 순수 함수가 불순 함수보다 기능적으로 우수하다는 의미는 아님
- `사이드 이펙트`가 발생하지 않는 표현식이나 순수 함수는 `결정론적`이며 `참조 투명성`의 특징을 가진다.
  - 다른 프로그램을 작성할 때도 코드를 변경하지 않고 재사용할 수 있다.
- 순수성과 참조 투명성은 서로 연결되어 있으며 이는 코드를 이해하고 추론하기 쉽도록 한다.

### 1.2.2 불변성
- `불변성`을 갖는 경우 초기화된 이후에는 자료 구조를 더 이상 변경할 수 없다.

  ➡️ 일관성 보장 / 예측 가능 / 이해하기 쉬움
- 불변 자료 구조는 순수 함수와 마찬가지로 비동기적이고 병렬적인 환경에서 안정적으로 작동하며 동기화 문제나 범위를 벗어난 상태 변경과 같은 문제를 초래하지 않는다.
- 그러나 자료 구조가 초기화 된 이후 절대 변경되지 않는다면 프로그램은 유용하지 않다.
- 자료구조를 직접 변경하는 대신에 변경된 상태를 포함하는 업데이트 된 새로운 버전 생성이 필요
- 매번 데이터가 변경될 때마다 새로운 자료구조를 생성하는 것은 번거롭고 비효율적
- 많은 프로그래밍 언어에서는 `구조 공유`<sub>structure sharing</sub>를 사용하여 효율적인 복사 메커니즘 제공
  - 자료 구조의 다른 인스턴스들은 불변 데이터를 공유하게 됨


### 1.2.3 재귀
- `재귀` : 동일한 형태의 문제를 부분적으로 해결하고 그 결과를 조합하여 최종적으로 원래의 문제를 해결하는 문제 해결 기법
- 순수 함수형 프로그래밍은 종종 반복문이나 반복자 대신에 재귀를 선호하는 경향이 있다.
- 반복적으로 함수를 호출하는 것은 비효율적일 수 있으며 스택 오버플로의 위험성을 갖는다. 잉런 이유로 많은 함수형 언어는 스택 프레임을 줄이기 위해 `꼬리 물기 최적화` 또는 `루프 언롤링`과 같은 최적화 기법 활용

### 1.2.4 일급 함수와 고차 함수
- 일급 함수 : 함수를 소위 '일급 객체'로 대우하는 것을 의미
  - 함수 자체를 다른 함수에 인스로 전달하거나 반환값으로 사용할 수 있으며 변수에 할당할 수 있는 함수
- 고차 함수 : 일급 객체의 특성을 바탕으로 함수를 인수로 받거나 반환하거나 또는 두 가지 모두를 가능하게 한다.

### 1.2.5 함수 합성
- 순수 함수를 결합하여 더 복잡한 표현식을 만들 수 있다.
![](https://cdn1.byjus.com/wp-content/uploads/2021/05/composite-functions.png)

### 1.2.6 커링
- 커링 함수 : 여러 개의 인수를 받는 함수들을 분리하여 인수를 하나씩만 받는 함수의 체인으로 변환
$$ x = f(a, b, c)$$
- 이를 커링 함수로 변환하면 다음과 같다.
$$ f = g(a) \\
i = h(b) \\
x = i(c)
$$
- 커링 함수 나열 :
$$
x = g(a)(b)(c)
$$

하스켈 같은 언어에서는 다음과 같이 표현된다.
```
add :: Integer -> Integer -> Integer (1)
add x y = x + y (2)
```
- (1) 함수 add는 정수를 입력받고 또 다른 정수를 입력받는 함수를 반환한다. 그리고 이 함수는 다시 정수를 반환한다.
- (2) 실제 정의는 선언을 반영한다. 두 개의 입력 매개변수와 바디의 결과가 반환값이 된다.

### 1.2.7 부분 적용 함수 애플리케이션
- 부분 적용 함수 애플리케이션 : 기존 함수의 인수 중 일부만 제공하여 새로운 함수를 생성하는 과정
- 커링과 다른 점 : 결과를 반환하며 커링 체인의 또 다른 함수를 반환하지 않음
```
add :: Integer -> Integer -> Integer
add x y = x + y

add3 = add 3

add3 5
```
- add 함수는 이전과 같이 두 개의 인수를 받는 형태로 선언된다.
- add 함수를 첫 번째 인수 x에 대한 값만 사용하여 호출하면 이름이 add3으로 바인딩된 Integer -> Integer 형태의 부분 함수를 반환한다.
- add 3 5라는 호출은 add 3 5와 동일하다.

### 1.2.8 느긋한 계산법
- 느긋한 계산법<sub>lazy evaluation</sub> : 표현식의 계산을 그 결과가 실제로 필요한 시점까지 지연시키는 계산 전략으로, 표현식을 어떻게 생성하는지와 해당 표현식을 언제 사용하는지에 대한 문제를 분리하는 개념
- lazyness는 무한한 자료 구조나 일부 알고리즘의 효율적인 구현과 같이, 다른 방식으로는 불가능한 구조들을 가능하게 함
- 표현식과 그 결과물 간에 차이가 없다면 결과에 영향을 주지 않고 연산을 지연할 수 있음
- 그러나 지연된 평가는 프로그램의 성능에 여전히 영향을 미칠 수 있음 (연산의 정확한 시기를 모를 수 있기 때문)

## 1.3 함수형 프로그래미의 장점
- 간결성 : 가변 상태에서 사이드 이펙트가 없는 경우 함수는 더 작아지며 '해야 할 일'만 수행
- 일관성 : 불변 자료 구조는 신뢰성과 일관성이 있음.
- (수학적) 정확성 : 일관된 자료 구조를 갖춘 더 간결한 코드는 자동으로 더 '정확한' 코드를 만들며 버그 발생 확률 ⬇️ / 디버깅과 테스팅도 간단해짐
- 안전한 동시성 : 함수형 개념을 활용해 다양한 문제를 해결하고 거의 비용 없이 안전한 병렬 처리의 이점을 누릴 수 있음
- 모듈성 : 작고 독립적인 함수는 간단한 재사용성과 모듈성 제공
- 테스트 용이성 : 순수 함수, 참조 투명성, 불변성, 역할 분리와 같은 많은 함수형 개념은 테스트와 검증을 더 쉽게 만듦

## 1.4 함수형 프로그래밍의 단점
- 학습 곡선
  - 함수형 프로그래밍은 고급 수학 용어와 개념을 기반으로하기 때문에 어렵게 느껴질 수 있음
  - 함수형 프로그래밍을 학습하는 동안에는 새롭고 낯선 용어와 개념에 직면하게 될 수 있음
- 고수준 추상화
  - 더 높은 추상화 수준을 사용해 자료 구조를 표현하기 때문에 이해하기 어려울 수 있음
- 상태 처리
  - 불변성 접근 방식은 자료 구조를 실제로 변경해야 하는 경우 상태 변경이 어려울 수 있음
  - setter 사용과 비교하면 더 어렵게 느껴질 수 있음
- 성능 영향도
  - 동시성 환경에서 사용하기가 더 쉽고 안전하지만, 다른 패러다임과 비교했을 때 반드시 빠르다는 것은 아님
- 최적의 문제 상황
  - 모든 문제 상황이 함수형 접근에 적합한 것은 아님
  - 고성능 컴퓨팅, I/O 중심의 문제 또는 저수준 시스템 및 임베디드 컨트롤러와 같은 도메인은 데이터 지역성과 명시적 메모리 관리와 같은 세부 사항에 민감하기 때문에 함수형 프로그래밍과는 어울리지 않을 수도 있음